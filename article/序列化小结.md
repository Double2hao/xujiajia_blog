#序列化小结
# 为什么要序列化

wiki的描述如下：

>  
 序列化在计算机科学的资料处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。 


笔者个人理解如下：
- **序列化**： “把当前环境的数据结构 转化成一种 可存储 或者 可传输的形式” 的过程。- **反序列化**： ”这种可传输或者可存储的形式 还原成 当前环境的数据结构“的过程。
>  
 此处为了便于读者理解举个例子： 现在有一个 Student类，有name，age等参数。 
 - 需求一，需要将这个类中的数据存储到本地，后面需要的时候再拿出来。 由于Student这个类是内存中的一个对象，不可以直接存储，那么就可以通过”序列化“将这个Student类转化成一种可以存储的形式，然后再存储。后面再通过”反序列化“将存储的数据还原成Student类。- 需求二，需要将这个Student的类，从客户端传输到服务端。 由于这个Student的类是客户端的一个对象，网络传输中无法直接使用，因此通过”序列化“将这个类转化成一种可以传输的形式，然后再传输。服务端接收到后，通过对应的”反序列化“将数据还原成自己环境中的对象。 


# 序列化种类

## 字符串序列化

### 代表
- json- xml
### 优势
- 使用方便，相关库多 json解析库有 Gson，jackson，FastJson xml解析库有 DOM, SAX, PULL- 拥有较好的表达能力。 如下，可以直接从序列化后的形式中看到数据所表达的内容。
```
{<!-- -->
    "config":{<!-- -->
        "id":"1234",
        "version":"0.1",
        "project_name":"test_project"
    }
}

```

### 劣势
- 传输效率低 JSON 和 XML 使用字符串表示所有的数据，对于非字符数据来说，字面量表达会占用很多存储空间。 一个 32 位浮点数 1234.5678 在内存中占用 4 字节 空间，存储为 utf8 则需要占用 9字节 空间，在utf16 表达字符串的环境中，需要占用 18 字节 空间。
## 二进制序列化

### 代表
- protocol buffers
### 优势
- 时间效率高 由于是二进制，编码与解码速度快。- 空间效率高 变长编码，减少浪费。 如：1<sub>15内的数字编码只会占用1个字节，16</sub>2047的数字编码会占2个字节。
### 劣势
- 使用相对麻烦，学习成本高 大致流程如：配置环境 -&gt; 确定数据结构，生成proto文件 -&gt; 项目添加相关依赖，并且使用proto文件 其中，每一个步骤都需要一定的学习成本，对于第一次接触的人无法直接上手。
# 常见的序列化方案以及场景

### 二进制序列化，如protocol buffers

场景：
1. 长连接场景（如游戏客户端与服务端的通信）
原因：
1. 对数据通信的速度以及大小都有要求
### 字符串序列化，如xml，json

场景：
1. 项目配置文件1. 短连接中用于传递某个临时数据，比如直接写在url的query中
原因：
1. 对序列化后内容的表达能力有一定要求 （配置文件一般也会有直接修改的需求）1. 对序列化的效率以及大小没有较严的要求1. 使用更为普遍的xml和json方案可以一定程度上减少各开发的沟通成本和提高开发效率。
# 拓展

>  
 对各种序列化方案的性能有兴趣的可以看下如下文章：  

