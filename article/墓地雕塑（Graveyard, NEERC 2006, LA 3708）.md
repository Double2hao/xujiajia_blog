#墓地雕塑（Graveyard, NEERC 2006, LA 3708）
# 题目：

在一个周长为10000的圆上等距分布着n个雕塑。现在又有m个新雕塑加入（位置可以随意放），希望所有n+m个雕塑在圆周上均匀分布。这就需要移动其中一些原有的雕塑。要求n个雕塑移动的总距离尽量小。

输入包含若干组数据。每组数据仅一行，包含两个整数n和m（2≤n≤1 000，1≤m ≤1 000），即原始的雕塑数量和新加的雕塑数量。输入结束标志为文件结束符（EOF）。

输入仅一行，为最小总距离，精确到10-4。

# 分析：

1、如果要总距离最小，尝试几次就知道，总会有一个点是不动的。 我们可以以这个不动的点为原点，建立一个长度为n的一维数轴。 然后把这个数轴分为m+n份。

2、数轴建立后，我们很容易就可以知道，原来的数轴上有n个点，每一个整数点，就是**原来的数轴上的雕塑的位置**。而新的数轴则有m+n个点。

3、这样问题就很简单了，只要让旧的数轴上的点去新的数轴上寻找离自己最近的点，然后把n-1个点的距离叠加。

## 代码

```
#include &lt;cstdio&gt;
#include &lt;cmath&gt;

int n ,m ;
double pos ,ans ;

int main()
{
    while(scanf("%d%d",&amp;n,&amp;m)!=EOF)
    {
        ans=0 ;
        for(int i=1;i&lt;n;i++)
        {
            pos=double(i)/n*(n+m);   //求i点在新的数轴上的坐标
            ans+=fabs(pos-int(pos+0.5));   //将i点移动的距离加入到ans中
        }
        printf("%.4lf\n",ans*10000/(n+m));
    }
    return 0;
}


```
