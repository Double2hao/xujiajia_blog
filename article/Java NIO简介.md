#Java NIO简介
>  
 原文地址：  


# 简介

个人理解，nio 最关键的地方是实现了io的多路复用问题。

# 引入多路复用的原因

实际上，在服务端与客户端一对一通信的时候，同步阻塞式地读写并不会有太大的问题，最典型的就是两个对等机器之间建立了TCP连接，并且通过TCP连接来发送一个大文件，有大量的数据传输。在这种场景中，阻塞式的写法简单高效。

但是，在服务器场景下，例如，一个 Web Server，它的特点是客户端很多，连接时间很短，数据发送量很小（一个网页几十到几百K），为了让每一个用户都能得到及时的响应，我们可以使用多线程的方式来实现服务端，例如这节课的例子：。

但是，一台服务器能创建的线程数是十分有限的，在Java中创建线程，一个线程默认就会预留1M的空间，那么1G的内存也不过只能支持1000个线程创建而已。而且，随着线程数的增多，线程之间的调度和切换，引发的资源竞争也会加剧，使整个系统变得很慢。

这个问题的最佳解决方案，就是select 和 epoll/poll。我们这节课的重点只放在 poll 上。select 和 epoll 就留给大家自己去学习了。

还是以上节课外卖的例子，来说明IO多路复用。在这节课里，我们看到了这样的例子：“如果我们整栋楼的人，很多人叫了外卖，都有下楼来看外卖到没到的需求，于是物业就出了个招，让门卫小哥帮大家看着，整栋楼上的，不管是谁的外卖到了，先放到门卫小哥那里，然后门卫小哥再通知你下来拿自己的外卖。这样一来，我们就把本来多个人要跑去看自己的外卖到了这件事交给门卫小哥去做了。而我们解放出来，就可以继续看电视，打扫卫生，刷知乎了。由于我们可以继续 做自己的事情，外卖小哥和门卫小哥在同时也在工作，互不干扰，所以这种工作方式就被称为异步模型”。

poll 就是我们引入的门卫小哥，可以帮助服务端把所有的客户端 socket 连接都管理起来。poll 可以同时观察许多 socket 的I/O事件， 如果所有的 socket 都空闲的时候，会把当前线程阻塞掉，当有一个或多个 socket 有I/O事件时，就从阻塞态中醒来，并且，它的返回值就是有IO事件的那一个或多个 socket。我们得到这些返回值以后，就可以逐个地处理这些socket上的IO事件了。这样，我们就把多个客户端，每个都要去做的轮询交给一个 poll 去实现了。
